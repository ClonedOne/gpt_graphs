python
Copy code
# Define the edges and ranks
edges = [(6, 1), (6, 2), (2, 7), (7, 3), (2, 8), (8, 4), (0, 8), (9, 6), (10, 5), (10, 1), (10, 9)]
ranks = {0: [0], 1: [8, 5], 2: [3, 1], 3: [6, 4, 7], 4: [9], 5: [2]}

# Iterate over the ranks
for rank in range(1, len(ranks)):
    nodes = ranks[rank]
    best_ordering = nodes[:]
    best_crossings = count_crossings(edges, ranks)
    
    # Try all possible transpositions and keep the one with the least crossings
    for i in range(len(nodes)):
        for j in range(i+1, len(nodes)):
            new_ordering = nodes[:]
            new_ordering[i], new_ordering[j] = new_ordering[j], new_ordering[i]
            crossings = count_crossings(edges, {**ranks, rank: new_ordering})
            if crossings < best_crossings:
                best_crossings = crossings
                best_ordering = new_ordering
                
    # Update the ranks with the best ordering for this rank
    ranks[rank] = best_ordering